use super::embed::Embed;
use super::guild::GuildMember;
use super::user::User;
use crate::error::Error;
use crate::model::emoji::Emoji;
use crate::model::id::{ApplicationId, AttachmentId, ChannelId, GuildId, MessageId, RoleId};
use crate::wrap_model;
use crate::Snowflake;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// A representation of a discord [text message] object
///
/// [text message]: https://discord.com/developers/docs/resources/channel#message-object
#[derive(Clone, Hash, Eq, PartialEq, Serialize, Deserialize, Debug)]
pub struct Message {
    /// id of the message
    pub id: MessageId,
    /// id of the channel the message was sent in
    pub channel_id: ChannelId,
    /// id of the guild the message was sent in
    pub guild_id: Option<GuildId>,
    /// the author of this message
    pub author: Option<User>,
    /// member properties for this message's author
    pub member: Option<GuildMember>,
    /// contents of this message
    pub content: String,
    /// when this message was sent
    pub timestamp: DateTime<Utc>,
    /// when this message was sent
    pub edited_timestamp: Option<DateTime<Utc>>,
    /// whether this was a Text-To-Speech message
    pub tts: bool,
    /// whether this message mentions everyone
    pub mention_everyone: bool,
    /// array of user objects
    pub mentions: Vec<User>,
    /// array of role object ids
    pub mention_roles: Vec<RoleId>,
    /// channels specifically mentioned in the message
    pub mention_channels: Option<Vec<ChannelMention>>,
    /// attached files
    pub attachments: Vec<Attachment>,
    /// any embedded content
    pub embeds: Vec<Embed>,
    /// reactions to the message
    #[serde(default)]
    pub reactions: Vec<Reaction>,
    /// used for validating a message was sent
    pub nonce: Option<String>,
    /// whether this message is pinned
    pub pinned: bool,
    /// if the message is generated by a webhook, this is the webhook's id
    pub webhook_id: Option<Snowflake>,
    /// type of the message
    #[serde(rename = "type")]
    pub kind: i32,
    /// sent with Rich Presence-related chat embeds
    pub activity: Option<Activity>,
    /// sent with Rich Presence-related chat embeds
    pub application: Option<Application>,
    /// reference data sent with crossposted messages
    pub message_reference: Option<MessageReference>,
    /// extra features of the message
    pub flags: i32,
}

#[derive(Clone, PartialEq, Eq, Hash, Debug, Deserialize, Serialize)]
pub struct MessageUpdate {
    pub id: MessageId,
    pub guild_id: Option<GuildId>,
    pub attachments: Option<Vec<Attachment>>,
    pub author: Option<User>,
    pub channel_id: ChannelId,
    pub content: Option<String>,
    pub edited_timestamp: Option<String>,
    pub embeds: Option<Vec<Embed>>,
    #[serde(rename = "type")]
    pub kind: Option<i32>,
    pub mention_everyone: Option<bool>,
    pub mention_roles: Option<Vec<RoleId>>,
    pub mentions: Option<Vec<User>>,
    pub pinned: Option<bool>,
    pub timestamp: Option<DateTime<Utc>>,
    pub tts: Option<bool>,
}

#[derive(Debug, Serialize, Deserialize, Eq, PartialEq, Clone, Hash)]
pub struct MessageDelete {
    id: MessageId,
    channel_id: ChannelId,
    guild_id: Option<GuildId>,
}

#[derive(Clone, PartialEq, Eq, Hash, Debug, Deserialize, Serialize)]
pub struct Reaction {
    /// times this emoji has been used to react
    count: i32,
    /// whether the current user reacted using this emoji
    me: bool,
    /// emoji information
    emoji: Emoji,
}

#[derive(Clone, PartialEq, Eq, Hash, Debug, Deserialize, Serialize)]
pub struct ChannelMention {
    /// id of the channel
    id: ChannelId,
    /// id of the guild containing the channel
    guild_id: GuildId,
    /// the type of the channel
    #[serde(rename = "type")]
    kind: i32,
    /// the name of the channel
    name: String,
}

#[derive(Clone, PartialEq, Eq, Hash, Debug, Deserialize, Serialize)]
pub struct Attachment {
    /// attachment id
    id: AttachmentId,
    /// name of file attached
    filename: String,
    /// size of the file in bytes
    size: i32,
    /// source url of the file
    url: String,
    /// a proxied url of file
    proxy_url: String,
    /// height of file (if image)
    height: Option<i32>,
    /// width of file (if image)
    width: Option<i32>,
}

#[derive(Clone, PartialEq, Eq, Hash, Debug, Deserialize, Serialize)]
pub struct Activity {
    /// type of message activity
    /// JOIN: 1
    /// SPECTATE: 2
    /// LISTEN: 3
    /// JOIN_REQUEST: 3
    #[serde(rename = "type")]
    kind: i32,
    /// Party ID from a Rich Presence Event
    party_id: Option<String>,
}

#[derive(Clone, PartialEq, Eq, Hash, Debug, Deserialize, Serialize)]
pub struct Application {
    /// id of the application
    id: ApplicationId,
    /// id of the embed's image asset
    cover_image: Option<String>,
    /// application's description
    description: String,
    /// id of the application's icon
    icon: Option<String>,
    /// name of the application
    name: String,
}

#[derive(Clone, PartialEq, Eq, Hash, Debug, Deserialize, Serialize)]
pub struct MessageReference {
    /// id of the originating message
    message_id: Option<MessageId>,
    /// id of the originating message's channel
    channel_id: ChannelId,
    /// id of the originating message's guild
    guild_id: Option<GuildId>,
}

wrap_model!(pub MessageWrapper, Message);

impl MessageWrapper {
    /// Send a message in the same text channel as the original message
    pub async fn reply(&self, content: impl AsRef<str>) -> Result<Message, Error> {
        self.rest_client()
            .create_message(self.channel_id, content.as_ref())
            .await
    }

    /// Delete this message
    pub async fn delete(&self) -> Result<(), Error> {
        self.rest_client()
            .delete_message(self.channel_id, self.id)
            .await
    }
}
